# HotSpot 虚拟机对象探秘（对象的加载--验证--初始化，对象内存分配策略，对象头，对象访问方式）

## 对象的内存布局

在 HotSpot 虚拟机中，对象的内存布局分为以下 3 块区域：

* 对象头（Header）
* 实例数据（Instance Data）
* 对齐填充（Padding）

![object-memory-layout.png](/images/object-memory-layout.png)

### 对象头

对象头记录了对象在运行过程中所需要使用的一些数据：

* 哈希码
* GC 分代年龄
* 锁状态标志
* 线程持有的锁
* 偏向线程 ID
* 偏向时间戳

对象头可能包含类型指针，通过该指针能确定对象属于哪个类。如果对象是一个数组，那么对象头还会包括数组长度。

### 实例数据

实例数据部分就是成员变量的值，其中包括父类成员变量和本类成员变量。

### 对齐填充

用于确保对象的总长度为 8 字节的整数倍。

HotSpot VM 的自动内存管理系统要求对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

> 对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。

## 对象的创建过程（类初始化之前，需要经过   加载--连接--初始化）

### 类加载检查

虚拟机在解析`.class`文件时，若遇到一条 new 指令，首先它会去检查常量池中是否有这个类的符号引用，并且检查这个符号引用所代表的类是否已被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程。
### 类加载过程
 当虚拟机遇到一条含有new的指令时，会进行一系列对象创建的操作：
（1）检查常量池中是否有即将要创建的这个对象所属的类的符号引用；
若常量池中没有这个类的符号引用，说明这个类还没有被定义！抛出ClassNotFoundException；（类的加载，说明new的时候会去加载目标类）
若常量池中有这个类的符号引用，则进行下一步工作；

（2）进而检查这个符号引用所代表的类是否已经被JVM加载；
若该类还没有被加载，就找该类的class文件，并加载进方法区；
若该类已经被JVM加载，则准备为对象分配内存；

（3）根据方法区中该类的信息确定该类所需的内存大小
一个对象所需的内存大小是在这个对象所属类被定义完就能确定的！且一个类所生产的所有对象的内存大小是一样的！JVM在一个类被加载进方法区的时候就知道该类生产的每一个对象所需要的内存大小。

（4）从堆中划分一块对应大小的内存空间给新的对象；分配堆中内存有两种方式：
指针碰撞 如果JVM的垃圾收集器采用复制算法或标记-整理算法，那么堆中空闲内存是完整的区域，并且空闲内存和已使用内存之间由一个指针标记。那么当为一个对象分配内存时，只需移动指针即可。因此，这种在完整空闲区域上通过移动指针来分配内存的方式就叫做“指针碰撞”。
空闲列表 如果JVM的垃圾收集器采用标记-清除算法，那么堆中空闲区域和已使用区域交错，因此需要用一张“空闲列表”来记录堆中哪些区域是空闲区域，从而在创建对象的时候根据这张“空闲列表”找到空闲区域，并分配内存。 综上所述：JVM究竟采用哪种内存分配方法，取决于它使用了何种垃圾收集器。

（5）为对象中的成员变量赋上初始值(默认初始化)；   成员变量初始化值，局部变量没有初始化值

（6）设置对象头中的信息；

（7）调用对象的构造函数进行初始化；

此时，整个对象的创建过程就完成了。

类什么时候才被初始化：

   1）创建类的实例，也就是new一个对象

　　2）访问某个类或接口的静态变量，或者对该静态变量赋值

　　3）调用类的静态方法

　　4）反射（Class.forName("com.lyj.load")）

　　5）初始化一个类的子类（会首先初始化子类的父类）

　　6）JVM启动时标明的启动类，即文件名和类名相同的那个类     

只有这6中情况才会导致类的类的初始化。类的初始化步骤：

        1）如果这个类还没有被加载和链接，那先进行加载和链接

        2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）

        3) 假如类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。

### 为新生对象分配内存

对象所需内存的大小在类加载完成后便可完全确定，接下来从堆中划分一块对应大小的内存空间给新的对象。分配堆中内存有两种方式：

- **指针碰撞**（完整内存，标记-整理或复制算法，移动指针即可）<br>
如果采用的是“**复制算法**”或“**标记整理法， Java **堆中内存绝对规整**，空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大小一样的距离，这种分配方式称为“**指针碰撞**”。

- **空闲列表**（有碎片的内存，标记-清除法，利用空闲列表进行维护空闲内存）<br>
如果采用的是**标记-清除法**，有碎片， Java **堆中内存并不规整**，已使用的内存和空闲内存交错，此时没法简单进行指针碰撞， VM 必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划分给对象实例。这种方式称为“**空闲列表**”。

### 初始化

分配完内存后，为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。

至此，整个对象的创建过程就完成了。

## 对象的访问方式

所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配的。也就是说在建立一个对象时两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针（引用）而已。 那么根据引用存放的地址类型的不同，对象有不同的访问方式。

### 句柄访问方式

堆中需要有一块叫做“句柄池”的内存空间，句柄中包含了对象实例数据与类型数据各自的具体地址信息。

引用类型的变量存放的是该对象的句柄地址（reference）。访问对象时，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址找到对象。

![handle-access](/images/handle-access.jpg)

### 直接指针访问方式

引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。但对象所在的内存空间需要额外的策略存储对象所属的类信息的地址。

![direct-pointer](/images/direct-pointer.jpg)

需要说明的是，HotSpot 采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要**额外的策略**来存储对象在方法区中类信息的地址。

（完）
---
👉 [Previous](/docs/01-jvm-memory-structure.md)<br>
👉 [Next](/docs/03-gc-algorithms.md)<br>
👉 [Back to README](../README.md)
